
import argparse
import sys, os, re, gzip, numpy, cPickle, itertools, gc, time, operator
import numpy as np
from scipy import stats
import readline
import rpy2.robjects as robjects
import statsmodels

## Python FDR: http://statsmodels.sourceforge.net/devel/generated/statsmodels.sandbox.stats.multicomp.multipletests.html#statsmodels.sandbox.stats.multicomp.multipletests
def multi_test_correction(pvals, method='bonferroni'):
	corrected_pvals = statsmodels.sandbox.stats.multicomp.multipletests(pvals, method)
	return list(corrected_pvals)


## multiple testing correction
## method can be any of the following:"holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none"
## see http://stat.ethz.ch/R-manual/R-devel/library/stats/html/p.adjust.html

def r_multi_test_correction(pvals, method='bonferroni'):
	r_p_adj = robjects.r['p.adjust']
	corrected_pvals = r_p_adj(robjects.FloatVector(pvals), method)
	return list(corrected_pvals)


def sliding_window2(iterable, size, step):
	len_iter = len(iterable)
	for i in xrange(0, len_iter - size + 1, step):
		yield iterable[i: i + size]


if __name__ == '__main__':
#	print 'The output file,', sys.argv[4], ', was generated by the following command:\n'
#	print ' '.join(sys.argv)

#	start_time = time.clock()

	parser = argparse.ArgumentParser()
	parser.add_argument("--statsFocal", default=None)
	parser.add_argument("--inputPickle_genomePBS")
	parser.add_argument("--outputFile", default=False)
	args = parser.parse_args()

	f_bed = gzip.open(args.statsFocal)
	dict_realDNA_selscan = {}
	dict_intvCoords_statsFocal = {}

	for line in f_bed:
		if line.startswith("#chrom") or line.startswith("chrom"):
			continue

		tmp = line.strip().split()
		try:
			chrom = int(tmp[0])
		except ValueError:
			chrom = int(tmp[0][3:])

		lpos = int(tmp[1])
		rpos = int(tmp[2])

		if chrom not in dict_realDNA_selscan:
			dict_realDNA_selscan[chrom] = []
			dict_intvCoords_statsFocal[chrom] = {}
		dict_realDNA_selscan[chrom].append((lpos, rpos))
		dict_intvCoords_statsFocal[chrom][(lpos, rpos)] = line.strip()
	

	with gzip.open(args.inputPickle_genomePBS) as fin:
		dict_chrom_PBS_genome, T_pop1, T_pop2, T_pop3, n2 = cPickle.load(fin)


	# for each chrom, sort entries in dict_realDNA_selscan[chrom]
	for chrom in sorted(dict_realDNA_selscan):
		dict_realDNA_selscan[chrom].sort()


	if T_pop1 == 0 or T_pop2 == 0 or T_pop3 == 0:
		raise ValueError('All numbers are identical in mannwhitneyu')


	# initialization for MW-U
	use_continuity = True

	list_results = []
	# slide through the entire genome and calculate MW-U
	for chrom in sorted(dict_chrom_PBS_genome):
		sorted_SNPkeys = numpy.array(dict_chrom_PBS_genome[chrom][0])
		PBSRank_pop1 = numpy.array(dict_chrom_PBS_genome[chrom][1])
		PBSRank_pop2 = numpy.array(dict_chrom_PBS_genome[chrom][2])
		PBSRank_pop3 = numpy.array(dict_chrom_PBS_genome[chrom][3])

		try:
			for i, win in enumerate(sorted(dict_realDNA_selscan[chrom])):
				l_pos = win[0] + 1
				r_pos = win[1]
				# find the indecies for SNPs in the current window.
				idx_overlap_SNPkeys = numpy.where((sorted_SNPkeys >= l_pos) & (sorted_SNPkeys <= r_pos))[0]
				if idx_overlap_SNPkeys.size != 0:
					# extract PBS ranks for the snps in the current window
					window_avail_SNPs = len(idx_overlap_SNPkeys)
					window_PBSRank_pop1 = PBSRank_pop1[list(idx_overlap_SNPkeys)]
					window_PBSRank_pop2 = PBSRank_pop2[list(idx_overlap_SNPkeys)]
					window_PBSRank_pop3 = PBSRank_pop3[list(idx_overlap_SNPkeys)]

					# initialization for MW-U
					n1 = window_avail_SNPs
					sd_pop1 = np.sqrt(T_pop1 * n1 * n2 * (n1 + n2 + 1) / 12.0)
					sd_pop2 = np.sqrt(T_pop2 * n1 * n2 * (n1 + n2 + 1) / 12.0)
					sd_pop3 = np.sqrt(T_pop3 * n1 * n2 * (n1 + n2 + 1) / 12.0)

					meanrank = n1 * n2 / 2.0 + 0.5 * use_continuity

					#rankx = np.asarray(window)
					u1_pop1 = n1 * n2 + (n1 * (n1 + 1)) / 2.0 - np.sum(np.asarray(window_PBSRank_pop1), axis=0) # calc u for x
					u2_pop1 = n1 * n2 - u1_pop1  # the remainder is u for y

					u1_pop2 = n1 * n2 + (n1 * (n1 + 1)) / 2.0 - np.sum(np.asarray(window_PBSRank_pop2), axis=0) # calc u for x
					u2_pop2 = n1 * n2 - u1_pop2  # the remainder is u for y

					u1_pop3 = n1 * n2 + (n1 * (n1 + 1)) / 2.0 - np.sum(np.asarray(window_PBSRank_pop3), axis=0) # calc u for x
					u2_pop3 = n1 * n2 - u1_pop3  # the remainder is u for y

					# perform a one-sided test with alternative 'greater' for x
					bigu_pop1 = u2_pop1
					z_pop1 = (bigu_pop1 - meanrank) / sd_pop1
					p_pop1 = stats.norm.sf(z_pop1)
					
					bigu_pop2 = u2_pop2
					z_pop2 = (bigu_pop2 - meanrank) / sd_pop2
					p_pop2 = stats.norm.sf(z_pop2)
					
					bigu_pop3 = u2_pop3
					z_pop3 = (bigu_pop3 - meanrank) / sd_pop3
					p_pop3 = stats.norm.sf(z_pop3)
					
					result = '\t'.join([str(x) for x in [p_pop1, p_pop2, p_pop3]])
					new_out = dict_intvCoords_statsFocal[chrom][(l_pos-1, r_pos)] + "\t" + result + "\n"
					dict_intvCoords_statsFocal[chrom][(l_pos-1, r_pos)] = new_out
				else:
					result = "\t".join(["NA", "NA", "NA"])
					new_out = dict_intvCoords_statsFocal[chrom][(l_pos-1, r_pos)] + "\t" + result + "\n"
					dict_intvCoords_statsFocal[chrom][(l_posi-1, r_pos)] = new_out
#					exit("Error! No data for %s:%s-%s" % (chrom, l_pos-1, r_pos))

		except KeyError:
			continue

	with gzip.open(args.outputFile, 'wb') as fout:
		for chrom in dict_intvCoords_statsFocal:
			for k in dict_intvCoords_statsFocal[chrom]:
				fout.write(dict_intvCoords_statsFocal[chrom][k])



