## this script is for gathering the GSEA results, perSNP Fst + MWU, from the 1000 whole genome simulations
## Usage:
## 	python  GSEA_pValue_using_simulationGSEA_individualFst_result.v3.py  _option_Bonferroni_fdr  _fname_realData_GSEA_UsingIndividualFst  _path_GSEA_simulations  __out_fname  > yri_pygmy_bytemapFiltered_geneSetEnrich_using_realDNA_wcFst_v4.c5_pathways.GSEA.wFracSigOverSims.log
## 
## For "_option_Bonferroni_fdr", one can choose to use Bonferroni-p or fdr-p to run the analysis here.
## Note that the output contains three more columns in addition to the original six columns of the results of real data GSEA results
## There three are : "number_simulation_GSEA", "frac_GSEAsims_less_1e-2", "frac_GSEAsims_less_1e-10" 
## The fraction, for each set, refers to the proportion of the simulations that reach a given significant level (1e-2/1e-10)
## Also, the amount of significant sets, for each simulation, is also printed to standard output.


import sys, os, time, gzip
import scipy.stats as stats
from collections import deque

if __name__ == '__main__':

	print '#The output file, ' +  sys.argv[3] + ', is generated by:' + ' '.join(sys.argv) + ' >' + sys.argv[3] + '.log'

	realdata_GSEA = gzip.open(sys.argv[1])
	list_path_simulation_GSEAfiles = [os.path.abspath(x) for x in sys.argv[2:-1]]
	list_simulation_GSEAfiles = []
	for path_sim in list_path_simulation_GSEAfiles:
		list_simulation_GSEAfiles.extend([os.path.join(path_sim,x) for x in os.listdir(path_sim)])

	out_fobj = gzip.open(sys.argv[-1], 'wb')

	# start calculating fractions of simulations, whose p values meet the two pvalue cutoffs: 1e-2 and 1e-10 
	dict_GSEA_vals = {}
	dict_sim_sigs = {}	
	dict_out = {}
	out_header1 = []

	for line in realdata_GSEA:
		if line.startswith('chrom') or line.startswith('#'):
			out_header1 = line.strip() + '\trank\tNUMsims\tPROPsims_Greater_obsUstat\tPROPsims_BonfP_Less0.05\tPROPsims_Smaller_obsBonfP\tPROPsimSets_Higher_obsRank\n'
			continue

		formatted_line = []
		for x in line.strip().split():
			try:
				formatted_line.append(float(x))
			except ValueError:
				formatted_line.append(x)

#		formatted_line = [int(x) for x in line.strip().split()]
		key = (formatted_line[0], formatted_line[1], formatted_line[2])
		# the list of each key has the formate [ #sims, #sims >= obs_U_stat, #sims_Bonf_p <= 0.05, #sims <= obs_Bonf_p, #simSets <= obs_Rank]
		dict_GSEA_vals[key] = [ 0, 0, 0, 0, 0]
		dict_out[key] = formatted_line

	# add the rank of each window to dict_out
	list_ranks = deque(stats.rankdata([vals[5] for win,vals in dict_out.iteritems()]))
	for win in dict_out:
		dict_out[win].append(list_ranks.popleft())

	# loop through all GSEA files for simulation data sets.
	for f in list_simulation_GSEAfiles:
		if not f.endswith('selscanCmpFst.gz'):
			continue

		dict_win_BonfP = {}
		# counts of significant sets for the first three significant measurements: (#sims >= obs_U_stat), (#sims_Bonf_p <= 0.05), and (#sims <= obs_Bonf_p)
		count_sigs = 0

		f_obj = gzip.open(f)
		for line in f_obj:
			if line.startswith('chrom') or line.startswith('#'):
				continue	

			formatted_line = [float(x) for x in line.strip().split()]
			sim_key = (int(formatted_line[0]), formatted_line[1], formatted_line[2])

			# store Bonf_p of each window for rank calculation
			dict_win_BonfP[sim_key] = [formatted_line[5]]

			if sim_key in dict_GSEA_vals:
				# for each set, count number of available simulations
				dict_GSEA_vals[sim_key][0] += 1

				# for each window, count #simulations with U stat >= observed U
				if formatted_line[3] >= dict_out[sim_key][3]:
					dict_GSEA_vals[sim_key][1] += 1
				# for each window, count # simulations with Bonf p <= 0.05
				if formatted_line[5] <= 0.05:
					dict_GSEA_vals[sim_key][2] += 1
					count_sigs += 1
				# for each window, count # simulations with Bonf p <= observed Bonf p
				if formatted_line[5] <= dict_out[sim_key][5]:
					dict_GSEA_vals[sim_key][3] += 1

		# report the numbers of significant sets for each of first three significant measurements
		dict_sim_sigs[f] = count_sigs

		# calculate ranks for windows in each simulation based on Bonf p
		list_ranks = deque(stats.rankdata(dict_win_BonfP.values()))
		
		# for each window, count # simulations with rank higher than observed rank
		for win in dict_win_BonfP:
			sim_rank = list_ranks.popleft()
			if sim_rank <= dict_out[win][-1]:
				dict_GSEA_vals[win][4] += 1


	# walk through sets and calculate, for each set, the fractions of significance over the simulations.
	out_list = []
	for k in dict_GSEA_vals:
		# for the case of cutoff 1e-2
		try:
			frac_sig_1 = float(dict_GSEA_vals[k][1])/(dict_GSEA_vals[k][0])
			frac_sig_2 = float(dict_GSEA_vals[k][2])/(dict_GSEA_vals[k][0])
			frac_sig_3 = float(dict_GSEA_vals[k][3])/(dict_GSEA_vals[k][0])
			frac_sig_4 = float(dict_GSEA_vals[k][4])/(dict_GSEA_vals[k][0])
		except ZeroDivisionError:
			if dict_GSEA_vals[k][0] == 0:
				frac_sig_1 = 'NA'
				frac_sig_2 = 'NA'
				frac_sig_3 = 'NA'
				frac_sig_4 = 'NA'
			else:
				exit('Error occurred! ', k, ':', dict_GSEA_vals[k])

		dict_out[k].extend([dict_GSEA_vals[k][0], frac_sig_1, frac_sig_2, frac_sig_3, frac_sig_4])
	
	out_fobj.write(out_header1)
	for key in sorted(dict_out):
		out_fobj.write('\t'.join([str(x) for x in dict_out[key]]) + '\n')

	print '#Name_simulation\t#windows_Bonf<=5e-2'
	for key in dict_sim_sigs:
		print key.split('/')[-1] + '\t' + str(dict_sim_sigs[key])

